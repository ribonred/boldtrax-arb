//! `client_order_id` encoding/decoding for Binance.
//!
//! Binance constraints on `clientOrderId`:
//! - Max 36 characters
//! - Alphanumeric + hyphens only
//!
//! This bot encodes the `internal_id` directly as the `client_order_id`.
//! The `internal_id` is already structured as:
//!
//! ```text
//! {strategy_id}-{timestamp_ms}-{exchange_short_code}
//! e.g. "funding_arb-1737410400000-BN"
//! ```
//!
//! Because the `strategy_id` is always the first segment (before the first
//! `-`), decoding is unambiguous without any extra delimiters.

const MAX_LEN: usize = 36;

pub struct BinanceClientOrderIdCodec;

impl BinanceClientOrderIdCodec {
    /// Encodes `internal_id` as the Binance `client_order_id`.
    /// Truncates to 36 characters if the internal_id exceeds Binance's limit.
    pub fn encode(&self, internal_id: &str, _strategy_id: &str) -> String {
        if internal_id.len() <= MAX_LEN {
            internal_id.to_string()
        } else {
            internal_id[..MAX_LEN].to_string()
        }
    }

    /// Extracts the `strategy_id` â€” the first `-`-delimited segment.
    ///
    /// Returns `None` for IDs not generated by this bot (e.g. manual trades).
    pub fn decode_strategy_id(&self, client_order_id: &str) -> Option<String> {
        let segment = client_order_id.split('-').next()?;
        if segment.is_empty() {
            return None;
        }
        Some(segment.to_string())
    }

    /// Returns the `internal_id` for a given `client_order_id`.
    ///
    /// For Binance the two values are identical (client_order_id IS the
    /// internal_id, possibly truncated), so this just returns the full string.
    pub fn decode_internal_id(&self, client_order_id: &str) -> String {
        client_order_id.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn codec() -> BinanceClientOrderIdCodec {
        BinanceClientOrderIdCodec
    }

    #[test]
    fn round_trip_standard() {
        let c = codec();
        let internal_id = "funding_arb-1737410400000-BN-0";
        let encoded = c.encode(internal_id, "funding_arb");
        assert_eq!(encoded, internal_id);
        assert_eq!(c.decode_strategy_id(&encoded), Some("funding_arb".into()));
        assert_eq!(c.decode_internal_id(&encoded), internal_id);
    }

    #[test]
    fn truncated_still_decodes_strategy() {
        let c = codec();
        // internal_id longer than 36 chars
        let long_id = "very_long_strategy_name-1737410400000-BN-0";
        assert!(long_id.len() > 36);
        let encoded = c.encode(long_id, "very_long_strategy_name");
        assert_eq!(encoded.len(), 36);
        // strategy_id segment is still intact
        assert_eq!(
            c.decode_strategy_id(&encoded),
            Some("very_long_strategy_name".into())
        );
    }

    #[test]
    fn returns_none_for_external_order() {
        let c = codec();
        // An order placed on the Binance UI has no `-` separator
        assert_eq!(
            c.decode_strategy_id("manualorder123"),
            Some("manualorder123".into())
        );
    }

    #[test]
    fn encoded_length_within_limit() {
        let c = codec();
        let id = "a".repeat(100);
        assert!(c.encode(&id, "").len() <= MAX_LEN);
    }
}

//! `client_order_id` encoding/decoding for Bybit V5.
//!
//! Bybit constraints on `orderLinkId`:
//! - Max 36 characters
//! - Alphanumeric + hyphens + underscores
//!
//! The `internal_id` is encoded directly as the `orderLinkId`.

const MAX_LEN: usize = 36;

pub struct BybitClientOrderIdCodec;

impl BybitClientOrderIdCodec {
    /// Encodes `internal_id` as the Bybit `orderLinkId`.
    /// Truncates to 36 characters if the internal_id exceeds Bybit's limit.
    pub fn encode(&self, internal_id: &str, _strategy_id: &str) -> String {
        if internal_id.len() <= MAX_LEN {
            internal_id.to_string()
        } else {
            internal_id[..MAX_LEN].to_string()
        }
    }

    /// Extracts the `strategy_id` â€” the first `-`-delimited segment.
    ///
    /// Returns `None` for IDs not generated by this bot (e.g. manual trades).
    pub fn decode_strategy_id(&self, client_order_id: &str) -> Option<String> {
        let segment = client_order_id.split('-').next()?;
        if segment.is_empty() {
            return None;
        }
        Some(segment.to_string())
    }

    /// Returns the `internal_id` for a given `orderLinkId`.
    ///
    /// For Bybit the two values are identical (orderLinkId IS the
    /// internal_id, possibly truncated), so this just returns the full string.
    pub fn decode_internal_id(&self, client_order_id: &str) -> String {
        client_order_id.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn codec() -> BybitClientOrderIdCodec {
        BybitClientOrderIdCodec
    }

    #[test]
    fn round_trip_standard() {
        let c = codec();
        let internal_id = "funding_arb-1737410400000-BY-0";
        let encoded = c.encode(internal_id, "funding_arb");
        assert_eq!(encoded, internal_id);
        assert_eq!(c.decode_strategy_id(&encoded), Some("funding_arb".into()));
        assert_eq!(c.decode_internal_id(&encoded), internal_id);
    }

    #[test]
    fn truncated_still_decodes_strategy() {
        let c = codec();
        let long_id = "very_long_strategy_name-1737410400000-BY-0";
        assert!(long_id.len() > 36);
        let encoded = c.encode(long_id, "very_long_strategy_name");
        assert_eq!(encoded.len(), 36);
        assert_eq!(
            c.decode_strategy_id(&encoded),
            Some("very_long_strategy_name".into())
        );
    }

    #[test]
    fn encoded_length_within_limit() {
        let c = codec();
        let id = "a".repeat(100);
        assert!(c.encode(&id, "").len() <= MAX_LEN);
    }
}
